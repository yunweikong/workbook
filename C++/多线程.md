# C++多线程
```
关键词：多线程、线程池、内存池
```


##### 线程的概念
- 最大线程数取决于CPU核数，不过并不等于CPU核数

### C++11 thread库
- 创建线程：`std::thread thread1(func_name, 形式参数1, ...)`
- 线程被创建出来之后就独立运行，也就是说，主程序结束时线程可能并未结束
    - 由此引入了`thread`类的`join`成员函数等待线程结束再运行主线程
    - 具体实现方法？？？
- `detach`成员函数能分离线程主程序
    - 具体实现方法？？？
- **`joinable`成员函数**判断是否能调用`join`/`detach`函数

**使用`std::thread`时需要注意局部变量的问题**
- `std::thread`的默认行为是按值传递参数，也就是说，传入的参数会被拷贝到新线程的上下文中。如果你希望传递的是引用而不是拷贝，必须使用 `std::ref` 来显式地告诉 `std::thread` 传递引用。
    - `std::ref`常被用于：传递引用给STL容器&传递引用给多线程函数
- 使用`std::thread`创建线程并传递类成员函数时，需要**使用&来获取成员函数的地址**(&A::func)，同时还需要传递对象的指针（或引用）作为第一个参数。
* 特殊的，如果`std::thread`要使用类的private函数，增加一个友元函数是不推荐的
    * 使用 `std::bind` 或 `lambda 表达式`，又或是将线程启动封装在类的公共接口中才是正确做法


### 互斥锁/量 mutex库
- 首先创建一个mutex对象（一般是全局）；使用mtx.lock上锁，mtx.unlock解锁；
    - `lock`函数锁定互斥量，互斥不可用则阻塞，直到获取到锁。
    - `try_lock`尝试锁定互斥，不成功返回`false`
- 更推荐的是使用 std::lock_guard 代替手动的 lock() 和 unlock()，减少出现未解锁的风险（RAII）
    - `std::lock_guard<std::mutex> lock(mtx);  // 自动锁定和解锁` 简单可靠
    - `unique_lock`提供了更灵活的操作：它支持手动解锁和加锁，支持延迟加锁...
        - 对已经加过锁的互斥量`std::lock_guard<std::mutex> lock(mtx, std::adopt_lock)`；
            - 也可传入`std::defer_lock`暂不加锁，然后执行try_lock_for()等延时操作
        - 详细说明[https://www.apiref.com/cpp-zh/cpp/thread/unique_lock.html]
    - `std::scoped_lock` (C++17 起)



### 单例模式
`call_once`



