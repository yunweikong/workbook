# C++编码规范
### 命名
- 文件命名使用小写字母；
- 类的命名 使用`前缀 + 驼峰命名法`。
    - 当一个类需要暴露给其它工程使用时，应加上工程约定的前缀，前缀全部使用大写字母。
    - 类命名尽量使用完整英文单词，除非是常见的缩写
- struct、 typedef 与 enum 的命名原则与类相同
- **enum成员**采用**大写字母开头的驼峰写法**，且应在命名中体现 enum 名称，命名规则要一致

* 变量命名
    * 变量命名使用小写字母开头的驼峰写法，不加类型信息前缀，命名应使用能表达变量涵义的**完整英文单词**
    * 仅允许在 for 单层循环中的 i 和表示坐标的 x、 y、 z 上使用单字母变量， 其他情况下不允许使用。
    * **非static的类成员变量**前加上小写字母 `m_前缀`， **static的类成员变量**前 加上小写字母`s_前缀`
* 函数命名
    * 非类成员函数使用**大写字母开头**的驼峰写法
    * 除构造函数和析构函数外，**类成员函数使用小写字母开头的驼峰写法**
        * 名词属性的类成员函数命名分两种情况
            * 若欲获取的信息当成返回值返回， 则命名方式为`名词 或 名词+修饰语` 的样式；`title()`
            * 若欲获取的信息通过某个参数返回， 则命名方式为 `get+名词（+修饰语）` 的样式；`getSubViews(&outPointer)`
        * 动词属性的类成员函数命名方式为**动词+宾语**， 若宾语是 this, 应省略
        * 形容词属性的类成员函数命名方式为 is/has 等修饰语+形容词/名词
        * 返回对象指针的函数若内部分配了内存，应使用 copy, create 等关键字把该信息反映在函数名上
    
- 原则上宏的命名全部大写，如有必要单词间用下划线分隔。如无必要，不把一段代码定义成宏。
- 全局变量（注意事项见后文）
    - 全局变量前加小写`字母 g_ 前缀`
    - static 全局变量前加小写`字母 gs_前缀`

* 名称空间命名
    * 名称空间使用剪短的全小写英文单词命名。
    ```C++
    namespace chart    {....}
    ```
* **不允许使用 My 或自己的姓名作为以上命名的前缀**

### 头文件
- 头文件包含：在所有头文件中均使用 #ifndef + #define + #endif 来避免该文件被重复包含；宏的命名方式为 `__PROJECTNAME_FILENAME_H__`
- **前置声明**：当使用一两个前置声明就能编译通过时，不要在头文件里包含另一个头文件
    - 当一个类仅引用另一个类的指针或引用类型（不涉及对方的具体实现），可以在头文件中用前置声明来减少头文件的依赖。如果一个类确实需要访问另一个类的完整定义（例如调用其成员函数），则需要包含对方的头文件。

* 头文件包含顺序：在代码文件里包含多个头文件时，应按照如下顺序将头文件分组，每组之间使用空行隔开：
    a. 预编译头文件，通常是 stdafx.h；
    b. 与代码文件同名的头文件；
    c. 系统头文件；
    d. WPS 内部其他工程头文件；
    e. 本工程其他头文件；

### 类
- 类的**所有成员变量必须初始化**，只有成员变量没有函数的类，必须定义默认构造函数。
- 除非有特殊需求，在类的构造函数中仅进行不涉及具体功能的初始化操作，例如为成员变量赋零。
- 较复杂的初始化操作，应放在一个单独的`init()方法`中，由类实例的创建者负责调用。

* 若没有明确的将单参构造函数用于隐式类型转换的需求， 应使用`explicit`关键字。
* 若**没有明确的对类进行拷贝的需求， 应在 private 段中声明拷贝构造函数和赋值运算符**

- 继承
    - **只使用public继承**
    - 在语义明确的时候从父类继承具体实现，其他时候从抽象接口继承
        - 反过来说：如果父类的行为对子类来说没有明确的实现，应该只提供接口而不提供实现
    - 若类有虚函数，则析构函数也定义为虚函数
    - 父类中声明为 virtual 的函数，子类声明中**要明确标明为 `virtual` 以及 `override`**

* **尽量避免运算符重载**，除非是为了在容器类中使用而必须实现的

- 访问权限声明
    - 类声明中按 public, protected, private 的顺序声明函数和变量，**每个关键字仅占用一段**， 每一段中的声明顺序为：
        1. typedef, enum（变量名的声明）
        2. Q_OBJECT 及类似声明（Qt）
        3. 嵌套类，（可以认为是存在于该类命名空间（作用域）的外部类（也是局部类））
        4. 常量，（一般使用static全实例共享）
        5. 构造函数，虚构函数，成员函数，数据成员。
        ```C++
        class Example {
        public:
            // 1. typedef, enum
            typedef int MyInt;
            enum Color { Red, Green, Blue };

            // 2. Q_OBJECT 和类似声明
            Q_OBJECT  // Qt 特有的声明，启用元对象系统

            // 3. 嵌套类
            class NestedClass {
            public:
                void nestedFunction() { }
            };

            // 4. 常量
            static const int MAX_VALUE = 100;

            // 5. 构造函数、虚构函数、成员函数、数据成员
            Example() { }  // 构造函数
            virtual ~Example() { }  // 虚析构函数

            void doSomething() { }  // 成员函数

        private:
            int value;  // 数据成员
            static int instanceCount;  // 静态数据成员
        };
        ```

* **友元的定义和友类的定义应放在同一个文件中**
    * 便于代码的理解和维护 和 封装性和隐私性

### 函数与实现
- 参数
    - 参数排列顺序为**输入参数在前，输出参数在后**。
        - 使函数签名更具可读性
    - 引用作为输入参数时应配合`const`使用。**不使用缺省参数**。
    - **不允许一个参数即作为传入参数，又作为传出参数**。
        - 避免混淆

- 内联函数
    - 内联函数不超过10行，推荐仅对1行的函数进行inline。
    - 不使用循环或switch...case，不进行递归。
    - 在类定义体内实现的函数，不要加inline关键字。
    
* **避免使用异常（try...catch）。使用ATL和STL时，关闭异常或限制异常作用域**
    * 在性能要求极高的场合，很多开发人员选择不使用异常，而是通过返回错误代码或状态值来代替异常处理。（这种方法虽然增加了代码的复杂性，但能有效避免异常带来的性能开销）
* 类型编程
    * 不使用运行时类型信息。
    * 明确使用 `static_cast`, `const_cast` 进行类型转换，避免使用 dynamic_cast, 小心使用 reinterpret_cast。
* 宏：尽量使用 const、 enum、 inline 替代 #define。
* 类数据成员的引用：避免成员函数返回指向类成员的指针或引用。

### 注释
- 文件头注释应包括文件名，创建者，创建时间，功能描述和版权信息。
- 代码注释：注释使用//风格，应简洁清晰，不写没必要的注释。代码中不是很简单直观的地方需要增加注释
- 预处理宏注释：中间代码段较长的`#else` 与`#endif`之后用注释标明宏的名字


### 格式
##### 对齐与缩进
- 使用 Tab 进行对齐。
- 花括号上下对齐， 不允许将左花括号放在 if 等语句的末尾：
- 构造函数初始化列表和多个基类的中每一行逗号放前面，和冒号对齐
- 只有一行代码的 if 语句不加花括号。
- 当 if 语句中某一个分支有一行的以上代码时， if 的所有子句都要加括号
- 函数参数列表过长时，应换行：返回值类型、左括号应保持与函数名同一行，具体换行的方案有两种：和第一个参数对齐/和函数名对齐
- 函数类型为 const 时， const 关键字与最后一个参数同行
- 所有预编译宏顶格对齐
- 分为多行的布尔表达式中 && 与 || 置于行首。
- 换行应在运算符优先级最低的地方进行，尽可能避免把配对的括号分成两行。
- 当条件比较复杂时，应将高优先级的运算用括号明确标识出来
- 命名空间（namespace）内容不缩进

##### 空格
- 函数调用的括号前后之间不加空格，参数之间逗号之后加一个空格。