- C++应用场景：
	- 系统编程：开发操作系统、驱动程序、嵌入式系统
	- **游戏开发**
	- 高性能计算：如科学计算、**图形处理**、信号处理等
	- 嵌入式系统
	- 大数据处理：神经网络等

### C++特性
JAVA是面向对象语言，但C++并不是
- 面向对象特性：**封装 继承 多态**
- 封装：让内存连续访问的方式
	- 插入操作一定用链表吗？这要看程序的特性——理论上来说，链表的插入花费更少；但如果使用数组，虽然增大了插入操作的花费，但是能使得访问操作异常迅捷。考虑你的程序哪一部分的花费是可以忍受的？
- 继承：慎用，继承当然可能带来代价
	- “组合优于继承”这一原则在面向对象设计中常被提倡，因为组合提供了比继承更灵活、更可控的代码结构。

**类的设计并不都是纵向的，实际上很有可能是横向的；纵向的往往用继承，横向的（功能类）往往用组合**

- 多态：同一接口，不同表现
	- c++中有两种多态，通过函数重载或者函数模板实现的**静态多态**和通过虚函数实现的**动态多态**（当然也可以开除静态多态）

**模板元编程**：从上述模板的例子我们知道了模板是一类在编译期才确定类型的机制，它的目的是实现通用代码，但是它的特性是编译期确定，根据这一特点，提出模板元编程这一概念；现在变为了constexpr；

**类型转化**：static_cast 编译期转换（不过不要把基类转成子类）；reinterpret_cast是属于比较低级的转化，或者说更符合“强制转化”的定义（但有可能造成未定义的行为）；
const_cast用来去掉const类型的const限制；`*bit_cast`
**不要用const_cast去修改const类型的对象值，这属于未定义行为（编译器优化）**


**容器**
array`std::array<int, 10> a;`
vector
deque
list
forward_ list
set、multiset、 map、multimap
unordered set、unordered_ multiset、 unordered map、unordered_ multimap
`std::stack` 是一种 **容器适配器**，它并不是一个独立的容器，而是基于其他容器构建的。

- **尽量不要使用for循环，而是使用stl算法**；
- 内存池的池化技术


# 2
C++11的新特性
- C++11支持了多线程
	- 多线程本质来源于硬件，C++11时硬件开始支持多线程（2006-2010多核才发展起来）
	- 线程安全：“同时”？“缓存一致性”CPU和自己的cache交互，内存变更不更改cache？
	- 线程安全是一个复杂的问题，尽管我们可以通过原子操作或是线程锁保证线程的安全，但我们的程序并能保证线程的“危险”（CPU可能可以默认地保持缓存一致性）
- `shared_lock和unique_lock`：读取`shared_lock`，RAII`unique_lock`

RAII
- 智能指针`std::shared_ptr`：通过计算所有权得到“引用计数”，当最后一个引用计数为零时，所管理的对象会被自动释放
	- 不过，考虑到语义问题，在明确情况下，似乎直接用new&delete更明确
	- 应该当函数为不知道什么情况结束时（不了解什么时候&谁释放资源）使用`shared_ptr`
		- 1. **不要使用原始指针初始化多个shared_ptr**；2. **不要用栈中的指针构造 shared_ptr**（二次析构）
- `std::weak_ptr`：假如能使用，提升为shared_ptr，否则新构造资源；
	- 解环
- `std::unique_ptr`：希望独占

* 智能指针不应该使用裸指针

- Lambda表达式：1. 一次性函数 2. 对于需要频繁修改参数的，Lambda可以捕获而不用修改参数 3. lambda可以帮助const变量的初始化

`const double pi = 3.14;`：**类型安全**`const` 声明是一个具有类型的常量，编译器能够进行类型检查，避免类型不匹配的问题。

应该尽可能地使用auto
- 不要使用`std::vector<bool>`

因为存在IDE的返回值优化，所以对于临时变量，编译器可以利用 NRVO 进一步优化，直接在目标位置构造该对象——`return x优于return str::move(x)`


```
现代C++，语法，优化
```

```
C++的工程化内容
```

Unit单元测试：单个模块内部的功能测试
业务逻辑和算法：单元测试
Integration继承测试：